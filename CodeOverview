Overview:
This code works by generating massless test particles in random but structured locations following user input of parameters required for calculation. After clearing the folders form any previous runs of the code, the variables are fed into a (heavily) modified amalgamation of the Orbit Plot
(https://rebound.readthedocs.io/en/latest/ipython_examples/OrbitPlot/) and Test Particles(https://rebound.readthedocs.io/en/latest/ipython_examples/Testparticles/) examples 
provided in the Rebound Documentation(https://rebound.readthedocs.io/en/latest/). Rebound is an open source N-body integrator python package and is the backbone for this entire project. 

Note: This code has been modified to make it easier to read. Do not copy and paste. It will not work.


# User Set Parameters --------------------------------------------------------------
'''Code units are in cgs'''

NOTE: Yes I know using centimeters, grams, and seconds when talking about things of this scale is a bit silly but I've set up the code to do all of the necessary conversions for you later to make it easier to read


BHM = 5e8                     # Black hole mass in solar masses
KVZ = 3000e5                  # Kick velocity cm / s
KVX = 0
KVY = 0
RS = None                      # Set seed for repeatability
N_testparticle = 1000          # Number of test particles

NOTE: The number of test particles in the simulation is the one of the main factors in determining how fast the code will run (the other being your computer specs). If you've got a decent computer and you want quick simulations for producing animations I recommend running with 2,500 particles or less. If you want more detailed spectra then a minimum of 5,000 particles should suffice.

Nimg = 1501                    # Number of timeseteps to run simulation for

NOTE: Rebound determines the size of each timestep when using the IAS15 integrator

timesteps = [0, 100, 500, 1000, 1500]    # What timestep to print as profiles
ObsInc = [0]                   # Inclination of observer to generate profiles using


Y = 20                         # Size scaled to BLR
Tsub = 1500                    # Dust sublimation temperature
Eratio = 0.1                   # Eddington ratio
sigma = 1                      # Angular width
p = 0                          # Cloud distribution power law - 0 for uniform distribution
c =  2.998e10                  # Speed of light in cm/s
s =  0                         # Gas density distribution 0 - constant density -2 - 1/r^2 dropoff
n0 = 10**7                     # Value of gas density at outer radius


NOTE: In most cases it shouldn't be necessary to significantly modify the default parameters


# Calculated parameters--------------------------------------------------------

BHMg = BHM * 1.989e+33              # Solar mass to g
SwR = ((2*BHMg*(6.67e-8))/(c**2))   # Schwarzschild Radius (cm)
LEdd = 1.26e38*(BHMg/1.989e33)      # Eddington Luminosity
LAGN = Eratio*LEdd                  # Bolometric luminosity erg s**-1  Sum of all clouds should be around 10**40
Rd = (0.4*((((LAGN)/(10**45))**0.5)*((1500/Tsub)**2.6)))* 3.086e+18 # Dust sublimation radius
qagnratio = 2.6e55/10e45            # Base ratio of ionizing photon luminosity to AGN luminosity
Q = qagnratio*LAGN                  # Ionizing photon luminosity photons/s
incval = 0.35                       # Disk inclination
Cf = 0.3/np.sin(incval)             # Covering fraction for flared disk


NOTE: This program will require you to set up a few sub-folders to keep things organized. They should be named 
1. AnimationFolder
2. RawData
3. TimestepData
There are three variables for 3 different file paths you need to modify so the code knows where to put things

directory_path1 = 'Path/AnimationFolder'
directory_path2 = 'Path/RawData'
directory_path3 = 'Path/TimestepData'


When changing the simulation parameters, in order to avoid issues with things not overwriting correctly there is a cell that will completely clear the previous simulations files. You shouldn't need to run the File Deletion cell unless you wish to restart the simulation using different parameters.





# Simulation ------------------------------------------------------------------

"""Set up the particles in the simulation. Particles are added by default in
Jacobi coordinates (center-of-mass frame)"""

sim = rebound.Simulation()    # Initialize the simulation
sim.units = ('s', 'cm', 'g')  # Set simulation units
sim.ri_ias15.min_dt = 10000   # Set minimum timestep length in seconds
sim.add(m = BHMg)             # Add the central particle
primary=sim.particles[0]
np.random.seed(RS)            # Random seed for test cases


## Set up initial distribution of test particles --------------------------------

a_initial = np.linspace(Rd/Y, Rd, N_testparticle) # Initial range of semi major axis to distribute particles
'''Range determined by the dust sublimation radius and the size scaled to BLR'''

for a in a_initial:
    sim.add(a=a,
            inc = np.random.uniform(low = -incval, high = incval),    # Inclination
            Omega = np.random.uniform(high = np.pi),                  # Longitude of ascending node
            f=np.random.rand()*2.*np.pi)          # Mass is set to 0 by default, random true anomaly
    
        
# Integration -----------------------------------------------------------------

This is the part where the simulation actually runs and will loop for N timesteps that you specified in the initial set up.

ffor i in range(Nimg):
    if i == 0:
        # Print the base simulation before any modification

        coords = np.zeros((sim.N, 6))
        sim.serialize_particle_data(xyzvxvyvz=coords)
        fig, ([ax1, ax2], [ax3, ax4]) = plt.subplots(2,2, figsize = (12,10), dpi = 200)

        # XY graph


        # YZ graph

        # XZ graph


        # Empty space

        sim.step()
    
    else:
        #Add velocity kick

        sim.particles[0].vz = KVZ    # Changing the z velocity of the central particle to __ (in code units)
        sim.particles[0].vx = KVX
        sim.particles[0].vy = KVY      
        sim.step()                   # Move forward one timestep
        coords = np.zeros((sim.N, 6))
        sim.serialize_particle_data(xyzvxvyvz=coords)
        fig, ([ax1, ax2], [ax3, ax4]) = plt.subplots(2,2, figsize = (12,10), dpi = 200)

        # XY graph


        # YZ graph


        # XZ graph


        # Empty space


    if i % 500 == 0: # Saves every 100th timestep to an image to save space
        plt.savefig("Path/AnimationFolder/image_%s.jpg" % i)
        #Saving each plot to a file with it's own name to be created into a gif. I used https://ezgif.com/maker  
    sim.save_to_file("Path/RawData/archive.bin") 


#%% Begin Data Extraction------------------------------------------------------

Reads the simulation data from the binary file and splits it into individual timestep CSVs. The TimestepData folder will contain all of the data needed to calculate the luminosity for each individual timestep in its own CSV file. 


#%% Luminosity calculations and Spectra generation-----------------------------

In this mess of nested for loops the code is looping through each timestep and calculating all of the values for things like: cloud radial distance from center, Keplerian velocity, individual cloud radius, and gas density. Once we have those values we can determine the ionization state of each individual cloud and whether or not it is matter-bounded or radiation-bounded. From there that determines how we calculate the luminosity of that individual cloud. 

Once we have individual cloud luminosity the code will automatically sort each cloud into a velocity bin based on its line of sight velocity to the observer and sum up the total lumiosity in each bin, creating our spectrum for that timestep.


#%%
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Oct 18 21:17:46 2024

@author: karina
"""

import rebound
import numpy as np
import matplotlib.pyplot as plt
import os
import pandas as pd
import glob


# User Set Parameters --------------------------------------------------------------
'''Code units are in cgs'''


BHM = 6.5e8                    # Black hole mass in solar masses
KVZ = 45e5                      # Kick velocity cm / s
KVX = 0
KVY = 0
RS = None                      # Set seed for repeatability
N_testparticle = 1000          # Number of test particles
Nimg = 300                      # Number of frames 
LAGN = 10**45                  # ergs/s  use for dust sublimation radius
Y = 20                         # Size scaled to BLR
Qh = 2.6*10**55                # Ionizing photon luminosity photons*s^-1
Tsub = 1500                    # Dust sublimation temperature
Cf = 1                         # Covering fraction
ObsInc = 1                     # Inclination to observer
LAGN = 10**45                  # Bolometric luminosity erg s**-1  Sum of all clouds should be around 10**40
ObsInc = 90                    # Inclination to observer 0-90 degrees
Eratio = 1                     # Eddington ratio
sigma = 1                      # Angular width
p = 1                          # Cloud distribution power law
c =  2.998e10                  # cm/s


# Calculated parameters--------------------------------------------------------

BHMg = BHM * 1.989e+33              # Solar mass to g
SwR = ((2*BHMg*(6.67e-8))/(c**2))   # Schwarzschild Radius (cm)
Rd = (0.4*((((LAGN)/(10**45))**0.5)*((1500/Tsub)**2.6)))* 3.086e+18 # Dust sublimation radius


# Constants--------------------------------------------------------------------

alphaeff = 1.1*10**-13              # Effective recombination coefficient for Halpha cm^3*s^-1
alphaB = 2.6*10**-13                # Recombination coefficient for hydrogen cm^3*s^-1
Qh = 2.6*10**55                     # Ionizing photon luminosity photons*s^-1
h = 6.62607015*10**-27 
EffRecomb = 1.1 * 10**13            # cm^3 s^âˆ’1
nu = (c)/(656*10**-6)

plt.ioff() #Tells IDE to only save the plots and not display them for speed

# Removes previous files so the data is replaced if needed---------------------

def delete_files_in_directory(directory_path):
   try:
     files = glob.glob(os.path.join(directory_path, '*'))
     for file in files:
       if os.path.isfile(file):
         os.remove(file)
     print("All files deleted successfully.")
   except OSError:
     print("Error occurred while deleting files.")

directory_path1 = 'path/AnimationFolder'
directory_path2 = 'path/RawData'
directory_path3 = 'path/TimestepData'

delete_files_in_directory(directory_path1)
delete_files_in_directory(directory_path2)
delete_files_in_directory(directory_path3)


# Simulation ------------------------------------------------------------------

"""Set up the particles in the simulation. Particles are added by default in
Jacobi coordinates (center-of-mass frame)"""

sim = rebound.Simulation()    # Initialize the simulation
sim.units = ('cm', 's', 'g')  # Set simulation units
sim.ri_ias15.min_dt = 100     # Set minimum timestep length in seconds
sim.add(m = BHMg)              # Add the central particle
np.random.seed(RS)            # Random seed for test cases


# Set up the test particles ---------------------------------------------------

a_initial = np.linspace(Rd/Y, Rd, N_testparticle) # Initial range of semi major axis to distribute particles
for a in a_initial:
    sim.add(a=a,
            inc = np.random.uniform(low = -0.1, high = 0.1), # Inclination
            Omega = np.random.uniform(high = np.pi),         # Longitude of ascending node
            f=np.random.rand()*2.*np.pi) # Mass is set to 0 by default, random true anomaly
    
        
# Print parameters for easy copy-pasting---------------------------------------

print('Recoil z velocity in cm/s: ' + str(KVZ))
print('Recoil x velocity in cm/s: ' + str(KVX))
print('Recoil y velocity in cm/s: ' + str(KVY))
print('BH Mass: ' + str(BHM))
print('Number of test Particles: ' + str(N_testparticle))
print('Random seed: ' + str(RS))
print('Number of frames to generate: ' + str(Nimg))
print('Inner Radius: '+ str(Rd/Y))
print('Outer Radius: '+ str(Rd))
print('Schwarzschild Radius: '+ str(SwR))


# Integration -----------------------------------------------------------------

for i in range(Nimg):
    if i == 0:
        # Print the base simulation before any modification
        coords = np.zeros((sim.N, 6))
        sim.serialize_particle_data(xyzvxvyvz=coords)
        fig, ([ax1, ax2], [ax3, ax4]) = plt.subplots(2,2, figsize = (12,10), dpi = 200)

        # XY graph
        ax1 = plt.subplot(2,2,3)
        vz = coords[:,5]
        #plt.scatter(coords[:,0], coords[:,1], alpha = 0.25, s = 2.5)
        scatterxy = plt.scatter(coords[:,0], coords[:,1], c = vz, cmap = 'coolwarm_r', s = 2.5)
        plt.colorbar(scatterxy, label = 'Z-Velocity')
        plt.scatter(0,0, marker = '*', color = 'm', s = 75)
        ax1.set_title("XY")
        ax1.set_xlabel('Distance in cm')

        # YZ graph
        ax2 = plt.subplot(2,2,4)
        vx = coords[:,3]
        #plt.scatter(coords[:,2],coords[:,1], color = 'b', alpha = 0.25, s = 2.5)
        scatteryz = plt.scatter(coords[:,2], coords[:,1], c = vx, cmap = 'coolwarm', s = 2.5)
        plt.colorbar(scatteryz, label = 'X-Velocity')
        plt.scatter(0,0, marker = '*', color = 'm', s = 75)
        plt.yticks(color='w')
        ax2.set_title("YZ")
        ax2.set_xlabel('Distance in cm')

        # XZ graph
        ax3 = plt.subplot(2,2,1)
        vy = coords[:,4]
        #plt.scatter(coords[:,0],coords[:,2], color = 'b', alpha = 0.25, s = 2.5)
        scatterxz = plt.scatter(coords[:,0], coords[:,2], c = vy, cmap = 'coolwarm', s = 2.5)
        plt.colorbar(scatterxz, label = 'Y-Velocity')
        plt.scatter(0,0, marker = '*', color = 'm', s = 75)
        plt.xticks(color='w')
        ax3.set_title("XZ")
        ax3.set_ylabel('Distance in cm')

        # Empty space
        ax4 = plt.subplot(2,2,2)
        plt.scatter(0,0, alpha = 0)
        plt.axis('off')
        plt.tick_params(left = False, right = False , labelleft = False , labelbottom = False, bottom = False)
        ax4.set_title("SMBH Recoil\nInitial Z velocity (km/s): " + str(KVZ)+"\nInitial X velocity (km/s): "+ str(KVX)+"\nInitial Y velocity (km/s): "+ str(KVY)+'\nTimestep: '+ str(sim.t)+' seconds', fontsize = 13)
        sim.step()
    else:
        #Add velocity kick
        sim.move_to_hel()             # Move to the heliocentric reference frame
        sim.particles[0].vz = KVZ     # Changing the z velocity of the central particle to __ (in code units)
        sim.particles[0].vx = KVX
        sim.particles[0].vy = KVY        
        sim.move_to_hel()             # Move into the new central particle-frame
        sim.step()
        coords = np.zeros((sim.N, 6))
        sim.serialize_particle_data(xyzvxvyvz=coords)
        fig, ([ax1, ax2], [ax3, ax4]) = plt.subplots(2,2, figsize = (12,10), dpi = 200)

        # XY graph
        ax1 = plt.subplot(2,2,3)
        vz = coords[:,5]
        scatterxy = plt.scatter(coords[:,0], coords[:,1], c = vz, cmap = 'coolwarm_r', s = 2.5)
        plt.colorbar(scatterxy, label = 'Z-Velocity')
        plt.scatter(0,0, marker = '*', color = 'm', s = 75)
        ax1.set_title("XY")
        ax1.set_xlabel('Distance in cm')

        # YZ graph
        ax2 = plt.subplot(2,2,4)
        vx = coords[:,3]
        scatteryz = plt.scatter(coords[:,2], coords[:,1], c = vx, cmap = 'coolwarm', s = 2.5)
        plt.colorbar(scatteryz, label = 'X-Veloicty')
        plt.scatter(0,0, marker = '*', color = 'm', s = 75)
        plt.yticks(color='w')
        ax2.set_title("YZ")
        ax2.set_xlabel('Distance in cm')

        # XZ graph
        ax3 = plt.subplot(2,2,1)
        vy = coords[:,4]
        scatterxz = plt.scatter(coords[:,0], coords[:,2], c = vy, cmap = 'coolwarm', s = 2.5)
        plt.colorbar(scatterxz, label = 'Y-Velocity')
        plt.scatter(0,0, marker = '*', color = 'm', s = 75)
        plt.xticks(color='w')
        ax3.set_title("XZ")
        ax3.set_ylabel('Distance in cm')

        # Empty space
        ax4 = plt.subplot(2,2,2)
        plt.scatter(0,0, alpha = 0)
        plt.axis('off')
        plt.tick_params(left = False, right = False , labelleft = False , labelbottom = False, bottom = False)
        ax4.set_title("SMBH Recoil\nInitial Z velocity (km/s): " + str(KVZ)+"\nInitial X velocity (km/s): "+ str(KVX)+"\nInitial Y velocity (km/s): "+ str(KVY)+'\nTimestep: '+ str(f"{sim.t:.3e}")+' seconds', fontsize = 13)
    if i % 5 == 0:
        #Save to binary file so it doesn't lose precision
        plt.savefig("path/AnimationFolder/image_%s.jpg" % i)
        #Saving each plot to a file with it's own name to be created into a gif https://ezgif.com/maker  
    sim.save_to_file("path/RawData/archive.bin") 

    # while i < 49:
    #      if i % 2 == 0:
    #         plt.savefig("path/AnimationFolder/image_%s.jpg" % i)
    #         # Save to binary file so it doesn't lose precision
    #         sim.save_to_file("path/RawData/archive.bin") 
    #         #Saving each plot to a file with it's own name to be created into a gif https://ezgif.com/maker  
    #         i = i + 1
    # while i >= 49:
    #     if i % 10 == 0:
    #         plt.savefig("path/AnimationFolder/image_%s.jpg" % i)
    #         # Save to binary file so it doesn't lose precision
    #         sim.save_to_file("path/RawData/archive.bin") 
    #         #Saving each plot to a file with it's own name to be created into a gif https://ezgif.com/maker  
    #         i = i + 1
    plt.close()


# %% Begin Data Extraction

# Initialize Simulationarchive simulation--------------------------------------

sa = rebound.Simulationarchive("path/RawData/archive.bin")
N_archives = len(sa)


# Initialize empty data arrays-------------------------------------------------

save_times = np.zeros(N_archives)
# 2 dimensional array of size N saves and M particles
particles_x = np.zeros((N_archives, (N_testparticle + 1))) 
particles_y = np.zeros((N_archives, (N_testparticle + 1)))
particles_z = np.zeros((N_archives, (N_testparticle + 1)))
particles_vx = np.zeros((N_archives, (N_testparticle + 1)))
particles_vy = np.zeros((N_archives, (N_testparticle + 1)))
particles_vz = np.zeros((N_archives, (N_testparticle + 1)))


# Now loop through the saves and pull out all of the values of interest--------

for i, sim in enumerate(sa):
    save_times[i] = sim.t
    for j in range(1, sim.N):
        particles_x[i, j] = sim.particles[j].x
        particles_y[i, j] = sim.particles[j].y
        particles_z[i, j] = sim.particles[j].z
        particles_vx[i, j] = sim.particles[j].vx
        particles_vy[i, j] = sim.particles[j].vy
        particles_vz[i, j] = sim.particles[j].vz


# Save each individual parameter to its own CSV--------------------------------

x_data = np.concatenate([[save_times], particles_x.T])
np.savetxt('path/RawData/simXdata.csv',
           x_data, delimiter=', ')

vx_data = np.concatenate([[save_times], particles_vx.T])
np.savetxt('path/RawData/simVXdata.csv', 
           vx_data, delimiter=', ')

y_data = np.concatenate([[save_times], particles_y.T])
np.savetxt('path/RawData/simYdata.csv', 
           y_data, delimiter=', ')

vy_data = np.concatenate([[save_times], particles_vy.T])
np.savetxt('path/RawData/simVYdata.csv', 
           vy_data, delimiter=', ')

z_data = np.concatenate([[save_times], particles_z.T])
np.savetxt('path/RawData/simZdata.csv', 
           z_data, delimiter=', ')

vz_data = np.concatenate([[save_times], particles_vz.T])
np.savetxt('path/RawData/simVZdata.csv', 
           vz_data, delimiter=', ')


# Read CSV files into dataframes-----------------------------------------------

x = pd.read_csv('path/RawData/simXdata.csv')
y = pd.read_csv('path/RawData/simYdata.csv')
z = pd.read_csv('path/RawData/simZdata.csv')
vx = pd.read_csv('path/RawData/simVXdata.csv')
vy = pd.read_csv('path/RawData/simVYdata.csv')
vz = pd.read_csv('path/RawData/simVZdata.csv')


# Split CSVs into individual timestep CSVs-------------------------------------

var_list = ['X', 'Y', 'Z', 'Vx', 'Vy', 'Vz']     # Column titles
t_step = np.arange(len(sa))                         # Number of files it needs to make - Matches with # of images
df_list = [x, y, z, vx, vy, vz]               # List of dataframes
t_dict = {}
for i, t in enumerate(t_step):                   # Loop through each column in each parameter csv
    temp_df = pd.DataFrame()
    for j, df in enumerate(df_list):
        var = var_list[j]
        temp_df[var] = df.iloc[0:, i]
    # Save each timestep to separate CSV
    temp_df.to_csv(f'path/TimestepData/t{t}.csv')
    

#%% Luminosity Calculations------------------------------------------------------

timestep = 245    # What timestep to use for calculations
sim = sa[timestep]

xStep = pd.read_csv(f'path/TimestepData/t{timestep}.csv', usecols = ['X'])
xStep = xStep['X'].tolist()

yStep = pd.read_csv(f'path/TimestepData/t{timestep}.csv', usecols = ['Y'])
yStep = yStep['Y'].tolist()

zStep = pd.read_csv(f'path/TimestepData/t{timestep}.csv', usecols = ['Z'])
zStep = zStep['Z'].tolist()

vxStep = pd.read_csv(f'path/TimestepData/t{timestep}.csv', usecols = ['Vx'])
vxStep = vxStep['Vx'].tolist()

vyStep = pd.read_csv(f'path/TimestepData/t{timestep}.csv', usecols = ['Vy'])
vyStep = vyStep['Vy'].tolist()

vzStep = pd.read_csv(f'path/TimestepData/t{timestep}.csv', usecols = ['Vz'])
vzStep = vzStep['Vz'].tolist()


# Cloud radius-----------------------------------------------------------------

Rcl = np.linspace(10**12, 10**14, N_testparticle)
for r in Rcl:
    Rcl = Rcl
# Turne these into random np.random.uniform(low = -0.1, high = 0.1)
#Rcl = []
#for i in range(N_testparticle):
#    radius = np.random.uniform(low = 10**12, high = 10**14)
#    Rcl.append(radius)


# Gas and column density-------------------------------------------------------

nr = np.linspace(10**8, 10**9, N_testparticle)
for i in nr:
    nr = nr
    Nc = nr* Rcl


# Cloud radial distance from center(m) and Keplerian velocity------------------

Vkep = []
dist = []
r = []
for i in range(N_testparticle+1):
    r = (np.sqrt((sim.particles[i].x**2)+(sim.particles[i].y**2)+(sim.particles[i].z**2)))
    dist.append(r)
    with np.errstate(divide='ignore'):
        kep = np.sqrt((6.67259e-8*BHMg)/r)
        Vkep.append(kep)
        
Vkep.pop(0)
dist.remove(0)

# Ionization state of the cloud------------------------------------------------

Urt = []
for i in range(N_testparticle):
    U = (Qh/(4*np.pi*((dist[i])**2)*c*nr[i]))
    Urt.append(U)
   
Urt = np.array(Urt)


# Radiation vs Matter-bounded cloud--------------------------------------------

Lcl1 = np.zeros(N_testparticle) 
Lcl2 = np.zeros(N_testparticle) 
dc = np.zeros(N_testparticle)
ds = np.zeros(N_testparticle)
for i in range(N_testparticle):
    dc[i] = Rcl[i] #average path length through cloud (proportional to Rcl)
    ds[i] = ((c*Urt[i])/(alphaB*nr[i]))# From eqn 8 in paper


# Individual cloud luminosity--------------------------------------------------

for i in range(N_testparticle):
    if ds[i]<dc[i]:
        #elf.append((1/np.pi)*np.arcos(np.sin(theta)*np.cos(phi)))
        Lcl1[i] = nr[i]**2*(alphaeff)*h*(nu)*np.pi*(Rcl[i]**2)*ds[i] # For ds<dc Radiation bounded
    else:
        #elf.append(1)    
        Lcl2[i] = nr[i]**2*(alphaeff)*h*(nu)*np.pi*(Rcl[i]**2)*Rcl[i] # Matter bounded

print('Total Cloud luminosity for timestep', timestep, ':', sum(Lcl1+Lcl2))


# Belpro output for given timestep---------------------------------------------

Urt = pd.DataFrame(Urt, columns = ['U'])
Rcl = pd.DataFrame(Rcl, columns = ['Rcl'])
nr = pd.DataFrame(nr, columns = ['hden'])
Nc = pd.DataFrame(Nc, columns = ['Nc'])
Lcl1 = pd.DataFrame(Lcl1, columns = ['Lcl1'])
Lcl2 = pd.DataFrame(Lcl2, columns = ['Lcl2'])

AddData = pd.concat([Urt, nr, Nc, Rcl, Lcl1, Lcl2], axis=1)
list = [0,0,0,0,0,0]
AddData.loc[0] = list
AddData.to_csv(f'path/RawData/addData{timestep}.csv', index=False)

dfTemp = pd.read_csv(f'path/TimestepData/t{timestep}.csv')
dfTemp2 = pd.read_csv(f'path/RawData/addData{timestep}.csv')

OutputData = pd.concat([dfTemp,dfTemp2], axis = 1)
OutputData = OutputData.drop(OutputData.columns[[0]], axis = 1)
OutputData.to_csv(f'path/RawData/OutputData{timestep}.csv')


#%% Simulated Spectra

ObsInc = 45
plt.ion() 

data = pd.read_csv(f'path/TimestepData/t{timestep}.csv')


# Line of sight velocity-------------------------------------------------------

if ObsInc == 90:
    LoS = data['Vz']
    LoS = LoZ - KVZ

if ObsInc == 0:
    LoS = data['Vy']
    LoS = LoS - KVY

def rotate_x(matrix, angle): # Rotation about the x-axis by inclination of observer

    rotation_matrix = np.array([
        [1, 0, 0],
        [0, np.cos(angle), -np.sin(angle)],
        [0, np.sin(angle), np.cos(angle)]
    ])

    return np.dot(rotation_matrix, matrix)

theta = ObsInc*(np.pi/180)

if 0 < ObsInc < 90:
    angle = theta
    rotatedLoS = []
    coordinates = []
    rotatedKick = []
    for i in range(N_testparticle+1):
        posmatrix = np.array([sim.particles[i].x, sim.particles[i].y, sim.particles[i].z])
        velmatrix = np.array([sim.particles[i].vx, sim.particles[i].vy, sim.particles[i].vz])
        rotated_position = rotate_x(posmatrix, angle)
        rotated_velocity = rotate_x(velmatrix,angle)
        rotatedLoS.append(rotated_velocity)
        coordinates.append(rotated_position)
    for i in range(1):
        kickmatrix = np.array([KVX,KVY,KVZ])
        rotated_kick = rotate_x(kickmatrix,angle)
    LoS = [ x[2] for x in rotatedLoS]
    LoS = np.array(LoS) 
    correction = rotated_kick[2]
    LoS = LoS - correction

from scipy import stats

# Determine bin range----------------------------------------------------------

numbin = 250

if abs(LoS.max())> abs(LoS.min()):
    binsmax = LoS.max() 
    binsmin = -LoS.max()
if abs(LoS.max())< abs(LoS.min()):
    binsmax = -LoS.min()
    binsmin = LoS.min()

bin_width = (binsmax - binsmin) / numbin


# Total Luminosity in each bin-------------------------------------------------

zeros = pd.DataFrame([0])
Lvals = pd.concat([Lcl1,Lcl2], axis = 1)
Lval = Lvals['Lcl1'] + Lvals['Lcl2']
Lval = pd.concat([zeros, Lval])

LoS = np.array(LoS)
Lval = np.ravel(Lval)


Lsum, sortedV, Bin = stats.binned_statistic_dd(LoS, Lval, statistic='sum', bins = numbin)    


# Plot-------------------------------------------------------------------------

fig, ax = plt.subplots(figsize=(12, 6))

ax.plot(Lsum)
ax.set(title = 'Simulated Spectra\n Observation Angle: '+str(ObsInc)+' Degrees',
       ylabel = 'Total Luminosity (ergs/s)',
       xlabel = 'Velocity Bin (Number of Bins: '+str(numbin)+')')

xticks = np.arange(0, numbin+1, numbin/5)
index = xticks.astype(int).tolist()
sortedV = np.array(sortedV)
sortedV = np.transpose(sortedV)
labels = sortedV[index]

ax.set_xticks(xticks, labels = labels)
